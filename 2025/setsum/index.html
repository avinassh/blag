<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=generator content="Hugo 0.139.4"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://avi.im/blag/2025/setsum/"><title>Setsum - order agnostic, additive, subtractive checksum - blag</title>
<meta property="og:title" content="Setsum - order agnostic, additive, subtractive checksum - blag"><meta property="og:type" content="article"><meta property="og:description" content="A brief introduction to Setsum - order agnostic, additive, subtractive checksum"><meta name=description content="A brief introduction to Setsum - order agnostic, additive, subtractive checksum"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700"><link rel=stylesheet href=/blag/css/highlight.css><link rel=stylesheet href=/blag/css/journal.css><link href=/blag/index.xml rel=alternate type=application/rss+xml title=blag></head><body><div class=container><div class=site-header-nav><nav class=site-nav><a href=https://avi.im/blag/>Index</a></nav><div><span><a href=/blag/about>About</a></span>
<span><a href=/blag/now>Now</a></span></div></div><article class=post><header class=post-header><h1 class=post-title>Setsum - order agnostic, additive, subtractive checksum</h1><time class=post-date datetime="2025-09-12 22:49:24 +0530">12 Sep 2025</time></header><p>Setsum is an order agnostic, commutative checksum. It was developed by <a href=https://rescrv.net>Robert Escriva</a> at Dropbox&rsquo;s metadata team. In this short post, I&rsquo;ll explain why they&rsquo;re used and the math behind them. Jump to the end if you&rsquo;d like to see the code.</p><h2 id=introduction>Introduction</h2><p>Say you&rsquo;re building a database replication system. The primary sends logical operations to replicas, which apply them in order:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:#f92672>&#34;op&#34;</span>: <span style=color:#e6db74>&#34;add&#34;</span>, <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#e6db74>&#34;apple&#34;</span>}
</span></span><span style=display:flex><span>{<span style=color:#f92672>&#34;op&#34;</span>: <span style=color:#e6db74>&#34;add&#34;</span>, <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#e6db74>&#34;apple&#34;</span>}
</span></span><span style=display:flex><span>{<span style=color:#f92672>&#34;op&#34;</span>: <span style=color:#e6db74>&#34;remove&#34;</span>, <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#e6db74>&#34;orange&#34;</span>}
</span></span></code></pre></div><p>After the replica processes these changes (add two apples, remove an orange), how do you verify both nodes ended up in the same state?</p><p>One naive (rather horrible) approach is to dump both states and compare them directly. It&rsquo;s expensive, impractical, and doesn&rsquo;t scale. Instead, you can maintain checksums that update with each operation. When you&rsquo;re done, just compare the checksums; if they match, you&rsquo;re in sync. That&rsquo;s why distributed databases like Cassandra use Merkle trees for the same purpose.</p><p>Setsum is similar but has some nice properties that make it attractive over Merkle trees. They can be computed incrementally; the cost only depends on the change being applied, not the whole dataset. I also find them attractive because they let you remove items as well.</p><h2 id=properties>Properties</h2><p>Setsum has some interesting properties:</p><p><strong>1. Order doesn&rsquo;t matter.</strong> Both of these yield the same result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s1 <span style=color:#f92672>=</span> New()
</span></span><span style=display:flex><span>s1.add(<span style=color:#e6db74>&#34;apple&#34;</span>)
</span></span><span style=display:flex><span>s1.add(<span style=color:#e6db74>&#34;banana&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s2 <span style=color:#f92672>=</span> New()
</span></span><span style=display:flex><span>s2.add(<span style=color:#e6db74>&#34;banana&#34;</span>)
</span></span><span style=display:flex><span>s2.add(<span style=color:#e6db74>&#34;apple&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert_eq(s1, s2)
</span></span></code></pre></div><p><strong>2. You can remove items.</strong> These are equivalent:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s1.add(<span style=color:#e6db74>&#34;apple&#34;</span>)
</span></span><span style=display:flex><span>s1.add(<span style=color:#e6db74>&#34;banana&#34;</span>)
</span></span><span style=display:flex><span>s1.remove(<span style=color:#e6db74>&#34;apple&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s2.add(<span style=color:#e6db74>&#34;banana&#34;</span>)
</span></span><span style=display:flex><span>s2.add(<span style=color:#e6db74>&#34;banana&#34;</span>)
</span></span><span style=display:flex><span>s2.remove(<span style=color:#e6db74>&#34;banana&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert_eq(s1, s2)
</span></span></code></pre></div><p><strong>3. You can combine setsums.</strong> As you guessed already, these are equal:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s1.add(<span style=color:#e6db74>&#34;apple&#34;</span>)
</span></span><span style=display:flex><span>s1.add(<span style=color:#e6db74>&#34;banana&#34;</span>)
</span></span><span style=display:flex><span>s2.add(<span style=color:#e6db74>&#34;chikoo&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s3.add(<span style=color:#e6db74>&#34;banana&#34;</span>)
</span></span><span style=display:flex><span>s3.add(<span style=color:#e6db74>&#34;chikoo&#34;</span>)
</span></span><span style=display:flex><span>s3.add(<span style=color:#e6db74>&#34;apple&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert_eq(s1<span style=color:#f92672>+</span>s2, s3)
</span></span></code></pre></div><p>The only state you need to maintain is 256 bits, and all operations are <code>O(len(msg))</code> instead of depending on your entire dataset.</p><h2 id=the-internals>The internals</h2><p>Each Setsum is an array of 8 unsigned 32-bit integers (u32), called &ldquo;columns&rdquo;. Each column starts at 0 when you create a new Setsum. Each column has an associated large prime number (close to <code>u32::MAX</code>).</p><p>When you add an item:</p><ul><li>Compute the SHA3-256 hash of the item (produces 32 bytes)</li><li>Split the hash into 8 chunks of 4 bytes each</li><li>Interpret each chunk as a little-endian u32</li><li>Add each number to its corresponding column</li><li>If the sum exceeds the column&rsquo;s prime, store the remainder (mod prime)</li></ul><p>You can also remove an item that was previously added. The magic is in computing the inverse: first, derive the inverse of the item&rsquo;s hashed value, then add that inverse to the setsum. This effectively cancels out the original, removing the item from the set!</p><p>To compute the inverse, we use modular arithmetic: it&rsquo;s simply the prime minus the value.</p><h2 id=the-math-behind-setsum>The math behind setsum</h2><p>Disclaimer: If we&rsquo;re friends, you already know I&rsquo;m no math person. If not, hey there, new friend! You can probably skip this if you understand modulo arithmetic, the Chinese remainder theorem, and a bit of probability.</p><p>Let&rsquo;s simplify: instead of 8 columns, let&rsquo;s use just one. The prime number for this column is 29. Consider adding these items with their hash and inverse values:</p><table><thead><tr><th>Item</th><th>Hash</th><th>Inverse</th></tr></thead><tbody><tr><td>apple</td><td>15</td><td>14</td></tr><tr><td>banana</td><td>23</td><td>6</td></tr><tr><td>chikoo</td><td>7</td><td>22</td></tr><tr><td>pomegranate</td><td>18</td><td>11</td></tr><tr><td>watermelon</td><td>26</td><td>3</td></tr></tbody></table><br>Notice that all hash values stay below the prime. If a hash exceeds it, we take the remainder. For example, if `guava` hashes to 33, the final value would be 4 (33 mod 29). Also, hash + inverse always equals the prime.<p>Let&rsquo;s add some items:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span> (add apple <span style=color:#f92672>-</span> <span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span> (add banana <span style=color:#f92672>-</span> <span style=color:#ae81ff>23</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span> (add chikoo <span style=color:#f92672>-</span> <span style=color:#ae81ff>7</span>)
</span></span></code></pre></div><p>Let&rsquo;s try in some random order:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span> (add chikoo <span style=color:#f92672>-</span> <span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>22</span> (add apple <span style=color:#f92672>-</span> <span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span> (add banana <span style=color:#f92672>-</span> <span style=color:#ae81ff>23</span>) <span style=color:#75715e>// see, this ends up same!
</span></span></span></code></pre></div><p>Let&rsquo;s try removal. Note that for removal we add the inverse values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span> (add apple <span style=color:#f92672>-</span> <span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span> (add banana <span style=color:#f92672>-</span> <span style=color:#ae81ff>23</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span> (add pomegranate <span style=color:#f92672>-</span> <span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span> (remove apple <span style=color:#f92672>-</span> <span style=color:#ae81ff>14</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span> (remove banana <span style=color:#f92672>-</span> <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>25</span> (add chikoo <span style=color:#f92672>-</span> <span style=color:#ae81ff>7</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span> (add pomegranate)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>25</span> (add chikoo) <span style=color:#75715e>// whoa 🤯
</span></span></span></code></pre></div><p>I cherry-picked these examples to demonstrate setsum, but there&rsquo;s a flaw in the above examples. Can you spot it?</p><p>Consider this collision:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>  (add apple <span style=color:#f92672>-</span> <span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>22</span>  (add chikoo <span style=color:#f92672>-</span> <span style=color:#ae81ff>7</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>  (add pomegranate <span style=color:#f92672>-</span> <span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#ae81ff>22</span>  (add guava <span style=color:#f92672>-</span> <span style=color:#ae81ff>4</span>)
</span></span></code></pre></div><p>Both sets of completely different items sum to 22! This happens because we&rsquo;re only using one column and a very small prime number. But add another column and the collision probability drops dramatically. With 8 columns, the probability of collision drops to <sup>1</sup>/<sub>2<sup>256</sup></sub>.</p><p>Setsum also uses SHA3-256 as its hash function, though the hash algorithm is replaceable. SHA3-256 is fast, has fewer collisions, and produces well-distributed hashes, so we can avoid the collision problem I showed above.</p><h2 id=observations>Observations</h2><ol><li><p>Setsum can tell you if states diverged, but not where. To narrow things down, you can split your data into smaller chunks and compare those. Build this into a hierarchical structure and you&rsquo;re basically back to something like a Merkle tree.</p></li><li><p>You can remove items that never existed. This might or might not be a problem depending on your use case. Given that you&rsquo;re only maintaining 256 bits of state, it&rsquo;s a reasonable tradeoff.</p></li><li><p>There&rsquo;s no history tracking. You can&rsquo;t tell when or how states diverged, just that they did.</p></li></ol><h2 id=code>Code</h2><p>The original Rust implementation is <a href=https://github.com/rescrv/blue/tree/main/setsum>here</a>. I ported it to Go, with all the same tests - <a href=https://github.com/avinassh/setsum>setsum</a>.</p><hr><p><small>1. I found out about setsum from Chroma&rsquo;s excellent post <a href=https://trychroma.com/engineering/wal3>wal3: A Write-Ahead Log for Chroma, Built on Object Storage</a> and got nerd sniped into writing this blog post</small><br><small>2. This is a good post: <a href=https://distributeddatastore.blogspot.com/2013/07/cassandra-using-merkle-trees-to-detect.html>Using Merkle trees to detect inconsistencies in Cassandra</a></p><p><small><i>Thanks to toc2, and General Bruh for reading an early draft of this post.</i></small></p></article><script async data-uid=0576bb9e32 src=https://avin.ck.page/0576bb9e32/index.js></script><footer class=site-footer><div class=rc-scout style=margin-right:auto;margin-top:auto;font-size:.6rem></div><script async defer src="https://www.recurse-scout.com/loader.js?t=a4aabd5087bb19daf083302de1b46650"></script><span class=person-schema itemscope itemtype=http://schema.org/Person><link itemprop=url href=https://avi.im/blag/><span itemprop=name></span><br><a itemprop=sameAs href=https://github.com/avinassh title=GitHub><img src=/blag/svg/gh.svg alt="icon name"></a>
<a itemprop=sameAs href=/blag/index.xml title=GitHub><img src=/blag/svg/rss.svg alt="icon name"></a></span></footer></div><script src=/blag/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script><script data-goatcounter=https://avi.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>