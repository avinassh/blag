<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=generator content="Hugo 0.139.2"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://avi.im/blag/2024/zero-disk-architecture/"><title>Zero Disk Architecture - blag</title>
<meta property="og:title" content="Zero Disk Architecture - blag"><meta property="og:type" content="article"><meta property="og:description" content="State is pain. The next generation of infrastructure tools will be built on diskless paradigm. In this short post I will explain what is Diskless / Zero Disk Architecture"><meta name=description content="State is pain. The next generation of infrastructure tools will be built on diskless paradigm. In this short post I will explain what is Diskless / Zero Disk Architecture"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700"><link rel=stylesheet href=/blag/css/highlight.css><link rel=stylesheet href=/blag/css/journal.css><link href=/blag/index.xml rel=alternate type=application/rss+xml title=blag></head><body><div class=container><div class=site-header-nav><nav class=site-nav><a href=https://avi.im/blag/>Index</a></nav><div><span><a href=/blag/about>About</a></span>
<span><a href=/blag/now>Now</a></span></div></div><article class=post><header class=post-header><h1 class=post-title>Zero Disk Architecture</h1><time class=post-date datetime="2024-11-24 17:20:31 +0530">24 Nov 2024</time></header><p><small>This is a follow up to my post: <a href=https://avi.im/blag/2024/disaggregated-storage/>Disaggregated Storage - a brief introduction</a></small></p><h2 id=state-is-pain>State is pain</h2><p>In my <a href=https://avi.im/blag/2024/disaggregated-storage/>previous post</a>, I explained how a disk attached to a machine makes things difficult. Vertical scaling has its limits, and when you hit that limit, you can&rsquo;t do horizontal scaling right away because of the attached disk. Mainstream databases like Postgres or MySQL don&rsquo;t scale horizontally. I recently learned that BlueSky team switched from Postgres to a combination of Scylla and SQLite. One of the reasons was because (vanilla) Postgres is not horizontally scalable, but Scylla is.</p><p>State is pain. Since the machine is stateful, you lose elasticity and scalability. So, the solution was to separate state from compute, so that they become independently scalable.</p><h2 id=disaggregated-storage>Disaggregated Storage</h2><p>Disaggregated Storage solves many problems associated with the traditional coupled architecture:</p><ul><li>Scalable and elastic. Limits of vertical scaling do not apply</li><li>Databases are &lsquo;serverless&rsquo; - instant startup and shutdown</li><li>Instant failover without any need of a hot standby</li></ul><p>But there was a big cliffhanger at the end of the post. The storage server. If I am writing a storage server, then won&rsquo;t I need to manage the state? It looks like we are back where we started. We need a storage server which is strongly consistent, elastic, horizontally scalable, and preferably has auto sharding.</p><p>So&mldr;what are my options?</p><ol><li><p>In large companies, you can offload the storage server problem to another team and live peacefully. For example, Amazon has a transaction log service (the details aren&rsquo;t public) which is used by Aurora and MemoryKV.</p></li><li><p>Use an existing open source storage engine. For Disaggregated Storage on SQLite, I went with this route and used Foundation DB. One problem with this approach is, you need to run and manage the cluster by yourself. I don&rsquo;t know any hosted KV Store providers.</p></li><li><p>Become a cracked engineer and build my own storage server. But this will take years! We want to ship fast and ship yesterday, so not an option.</p></li></ol><p>It seems most database companies roll their own storage server. However, there is one more option which is a mix of #1 and #2: Amazon S3.</p><h2 id=zero-disk-architecture>Zero Disk Architecture</h2><img src=/blag/images/2024/zero-disk-arch.svg alt="zero disk architecture" style=width:80%><p>The idea is simple. Instead of writing to a storage server, we will write to S3. Thus we will not manage any storage server, rather we offload it to the smart folks at AWS. S3 meets all our requirements. As a bonus, you get infinite storage space. S3 came out in 2006 and it has proven test of time. It is designed to provide <a href=https://x.com/iavins/status/1860621569355030696>99.999999999% (that&rsquo;s eleven nines) durability</a> and 99.99% availability guarantees. I believe the next generation of infrastructure systems will be built on zero disk paradigm.</p><p>This idea is not new. In 2008, there was a research paper <a href=https://people.csail.mit.edu/kraska/pub/sigmod08-s3.pdf>&lsquo;Building a Database on S3&rsquo;</a> - a paper way ahead of its time, with lots of interesting ideas for today&rsquo;s cloud computing. The researchers experimented with storing a B-tree on S3 using SQS as a Write-Ahead Log (WAL). They also provided analysis on latency when writing to S3 and the associated costs. The paper had some flaws, like they dropped ACID properties. However, we are in 2025, and we can do better.</p><p>Then, why has no one built such a system until now? My guess: latency and cost. However, S3 keeps getting better. They keep reducing the price all the time. The cost and latency are both going down as technology improves! Amazon S3 Express One Zone was launched last year and it&rsquo;s supposed to be 10x faster. Another reason I think is B-Tree vs LSM Tree. LSM Tree workload is more suited for S3. As most newer databases adapt to LSM, they&rsquo;re closer to S3. In the paper also they map B-Tree on S3.</p><p>Another reason I suspect is lack of features like conditional writes. Without this, you need an external system to provide transactional and ACID properties. S3 recently added this which gives you CAS-style operations on S3 objects.</p><p>Databases typically operate with pages, which are 4KiB in size. But object storages operate at much bigger sizes. The cost will be insanely high if we write every 4KiB object. So we will batch them at the compute layer till say 512KiB and then write all the pages as a single object. Suppose a transaction has sent a commit request, when do you acknowledge it as committed? If the local batch is not full, then do you make the client wait or cache the writes at compute and return success? If you do the latter, there is a risk of data loss. If you wait, then latency shoots up. Like everything in engineering, there is a trade-off: latency vs durability.</p><p>Smaller payloads also mean more requests, but that increases both cost and provides better durability and latency. This adds one more parameter: cost vs latency vs durability.</p><img src=/blag/images/2024/latency-cost-durability.svg alt="latency cost durability trade off" style=width:80%><p>I stole this trade-off diagram from <a href=https://jack-vanlightly.com/blog/2023/11/29/s3-express-one-zone-not-quite-what-i-hoped-for>Jack Vanlightly&rsquo;s excellent article</a>. Chris Riccomini also <a href=https://materializedview.io/p/cloud-storage-triad-latency-cost-durability>explored</a> this concept and coined catchy &lsquo;LCD model&rsquo; term.</p><img src=/blag/images/2024/s3-express-cache.svg alt="s3 express as a cache"><p>If you want to optimize for latency, you can first write to S3 Express One Zone (supposedly has single digit millisecond latency) and then offload that data to S3 later. In this case, One Zone becomes an intermediate cache server.</p><img src=/blag/images/2024/raft-cache.svg alt="raft cluster as a cache"><p>For OLTP databases, this can be still slow. That&rsquo;s why databases like <a href=https://neon.tech/blog/architecture-decisions-in-neon>Neon</a>, <a href=https://aws.amazon.com/blogs/storage/how-pingcap-transformed-tidb-into-a-serverless-dbaas-using-amazon-s3-and-amazon-ebs>TiDB</a> etc. have a Raft cluster setup which receives the writes. Then they are written to S3. This also saves on cost because instead of many smaller writes, you can make one large write to S3.</p><p>So depending on the trade-offs you want to make, you can write directly to S3 (standard or Express One Zone) or use a write through cache server. Zero disk architecture is also very attractive for systems where you don&rsquo;t care about latency. For example, OLAP databases, data warehouse systems.</p><p>Here are some systems which use S3 (or similar) as a primary store: <a href=https://event.cwi.nl/lsde/papers/p215-dageville-snowflake.pdf>Snowflake</a>, <a href=https://www.warpstream.com/blog/zero-disks-is-better-for-kafka>WarpStream</a>, <a href=https://slatedb.io/docs/architecture>SlateDB</a>, <a href=https://turbopuffer.com/architecture>Turbo Puffer</a>, <a href=https://aws.amazon.com/blogs/storage/clickhouse-cloud-amazon-s3-express-one-zone-making-a-blazing-fast-analytical-database-even-faster/>Clickhouse</a>, <a href=https://quickwit.io/docs/main-branch/overview/architecture>Quickwit</a>, <a href=https://milvus.io/docs/architecture_overview.md>Milvus</a>, <a href=https://wesql.io/docs/architecture>WeSQL</a>, <a href=https://www.trychroma.com/engineering/serverless>Chroma</a>, <a href=https://buf.build/blog/bufstream-kafka-lower-cost>Bufstream</a>, <a href=https://aws.amazon.com/blogs/storage/memq-by-pinterest-an-efficient-scalable-cloud-native-publish-subscribe-system/>MemQ</a>.</p><p>Zero Disk Architeture is a very compelling because you are not managing any storage server. You are not managing the state. The problem is for AWS S3 to deal with now. On top of it, you get all the benefits of disaggregated storage I highlighted earlier.</p><p>It&rsquo;s time we use the S3 as the brother Bezos intended. The malloc of the web.</p><hr><p><small>1. Any object store would work. But I like S3.</small><br><small>2. If any Amazon engineers would like to share more details about the Transaction Log, hit me up please.</small><br><small>3. Jack also wrote an excellent cost analysis: <a href=https://jack-vanlightly.com/blog/2024/6/10/a-cost-analysis-of-replication-vs-s3-express-one-zone-in-transactional-data-systems>A Cost Analysis of Replication vs S3 Express One Zone in Transactional Data Systems</a></small><br><small>4. In S3, if you store 100 billion objects, you <em>might</em> lose one in a year. To put it another way: if you store 10 million objects, you might lose one in 10,000 years. If a dinosaur had stored 1,000 objects, they may be still intact after 65 million years 🦖</small><br><small>5. Due to operational complexity and trade-offs, disaggregated storage (with/without zero disk architecture) makes sense primarily for database vendors and large tech companies, rather than organizations running just a few databases.</small><br><small><i>Thanks to Mr. Bhat, and Rishi for reading an early draft of this post.</i></small></p></article><script async data-uid=0576bb9e32 src=https://avin.ck.page/0576bb9e32/index.js></script><footer class=site-footer><div class=rc-scout style=margin-right:auto;margin-top:auto;font-size:.6rem></div><script async defer src="https://www.recurse-scout.com/loader.js?t=a4aabd5087bb19daf083302de1b46650"></script><span class=person-schema itemscope itemtype=http://schema.org/Person><link itemprop=url href=https://avi.im/blag/><span itemprop=name></span><br><a itemprop=sameAs href=https://github.com/avinassh title=GitHub><img src=/blag/svg/gh.svg alt="icon name"></a>
<a itemprop=sameAs href=/blag/index.xml title=GitHub><img src=/blag/svg/rss.svg alt="icon name"></a></span></footer></div><script src=/blag/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script><script data-goatcounter=https://avi.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>