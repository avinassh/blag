<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=generator content="Hugo 0.139.3"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://avi.im/blag/2024/s3-log/"><title>Building a distributed log using S3 (under 150 lines of Go) - blag</title>
<meta property="og:title" content="Building a distributed log using S3 (under 150 lines of Go) - blag"><meta property="og:type" content="article"><meta property="og:description" content="In this third part of the series, I will show how we can implement a durable, distributed, and highly available log using S3"><meta name=description content="In this third part of the series, I will show how we can implement a durable, distributed, and highly available log using S3"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700"><link rel=stylesheet href=/blag/css/highlight.css><link rel=stylesheet href=/blag/css/journal.css><link href=/blag/index.xml rel=alternate type=application/rss+xml title=blag></head><body><div class=container><div class=site-header-nav><nav class=site-nav><a href=https://avi.im/blag/>Index</a></nav><div><span><a href=/blag/about>About</a></span>
<span><a href=/blag/now>Now</a></span></div></div><article class=post><header class=post-header><h1 class=post-title>Building a distributed log using S3 (under 150 lines of Go)</h1><time class=post-date datetime="2024-11-30 23:16:21 +0530">30 Nov 2024</time></header><p>I will show how we can implement a durable, distributed, and highly available log using S3. This post is the third part in the series:</p><ol><li><a href=https://avi.im/blag/2024/disaggregated-storage/>Disaggregated Storage - a brief introduction</a></li><li><a href=https://avi.im/blag/2024/zero-disk-architecture/>Zero Disk Architecture</a></li><li>Building a distributed log using S3</li></ol><p>tl;dr The code is open source, comes with tests and open issues to contribute: <a href=https://github.com/avinassh/s3-log>s3-log</a></p><h2 id=log>Log</h2><img src=/blag/images/2024/log.svg alt=log><p>I love logs. The log is the heart of data and event streaming systems. A database is a log. Kafka is a log. Simply put, it&rsquo;s an ordered collection of records. The log is append-only, and once records are written, they are immutable. Each inserted record gets a unique, sequentially increasing identifier.</p><p>Log is a powerful storage abstraction. Using a log, you can build a database, message queue, or an event streaming system. If you would like to learn more, read this excellent blog post by Jay Kreps, the creator of Kafka: <a href=https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying>The Log: What every software engineer should know about real-time data&rsquo;s unifying abstraction</a>.</p><h2 id=why-s3>Why S3?</h2><p>In my previous post, I explained the benefits of <a href=https://avi.im/blag/2024/zero-disk-architecture/>Zero Disk Architecture</a>. A log on S3 is attractive for several reasons:</p><ol><li>No disks, so it is elastic and scalable.</li><li>We don&rsquo;t have to roll our own distributed storage server. We get durability, availability, and replication for free just by using S3.</li><li>No operational overhead.</li><li>Cost. Systems like <a href=https://www.warpstream.com/bring-your-own-cloud-kafka-data-streaming>WarpStream</a> and <a href=https://buf.build/blog/bufstream-kafka-lower-cost>BufStream</a> claim to be 10x cheaper than Kafka.</li><li>Customers and enterprises love BYOC! You make $$$</li></ol><h2 id=the-log-interface>The Log Interface</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Record</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Offset</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Data</span>   []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WAL</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>uint64</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>offset</span> <span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>Record</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We will write each payload as an object in S3 and ensure it gets a unique offset in the log. We need to make sure that record numbers are unique and sequentially increasing.</p><img src=/blag/images/2024/s3-log.svg alt="s3 log"><h3 id=append>Append</h3><p>The only &lsquo;write&rsquo; operation we can do on a log is <code>Append</code>. Append takes a bunch of bytes and writes them to the end of the log. It returns the offset, which is the position of this record in the log.</p><p>Let&rsquo;s define a struct that maintains a counter <code>length</code>. Every time we insert, we will increment this counter by one.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>S3WAL</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>client</span>     <span style=color:#f92672>*</span><span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>Client</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bucketName</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>length</span>     <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The very first record will have offset <code>0000000001</code>. For every new object we insert in the S3 bucket, we will increment it by one. Once a record is inserted, we will return its offset to the caller.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>S3WAL</span>) <span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>uint64</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nextOffset</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>input</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>PutObjectInput</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Bucket</span>:      <span style=color:#a6e22e>aws</span>.<span style=color:#a6e22e>String</span>(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>bucketName</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Key</span>:         <span style=color:#a6e22e>aws</span>.<span style=color:#a6e22e>String</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%020d&#34;</span>, <span style=color:#a6e22e>nextOffset</span>)),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Body</span>:        <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>data</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>IfNoneMatch</span>: <span style=color:#a6e22e>aws</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;*&#34;</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>PutObject</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>input</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to put object to S3: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>length</span> = <span style=color:#a6e22e>nextOffset</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>nextOffset</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>How do we prevent two writers appending records with same offset? This is one of the crucial property of a log. Using S3 Conditional Write it is very simple. That&rsquo;s why we have added <code>IfNoneMatch: aws.String("*")</code> in the request. If an object already exists with the same record offset, the request will be rejected. Let&rsquo;s write a basic test to confirm this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestSameOffset</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wal</span>, <span style=color:#a6e22e>cleanup</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getWAL</span>(<span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cleanup</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>&#34;threads are evil&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>wal</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;failed to append first record: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// reset the WAL counter so that it uses the same offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>wal</span>.<span style=color:#a6e22e>length</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>wal</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;expected error when appending at same offset, got nil&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You might be thinking, &ldquo;Why not use S3&rsquo;s latest append feature and write to the same object?&rdquo; We can certainly do that, but it&rsquo;s tricky to get right since a zombie writer might come back and append to an old object while a new leader is writing to a new file. Unlike typical Raft-based storage systems, S3 does not have a concept of fencing tokens. I&rsquo;ve left this optimization to tackle later.</p><p>I&rsquo;ve also kept the sequencing simpler by considering no gaps. If we allow gaps, it might be possible for a zombie writer to write to an old sequence number. There are ways to prevent this, but that&rsquo;s a problem for another day! (Note to self: I should probably write another blog post about these problems.)</p><h3 id=checksums>Checksums</h3><p>S3 provides 99.99999999% durability. But like any sane man, I would never trust an external system for data integrity. <a href=https://avi.im/blag/2024/databases-checksum/>Most databases don&rsquo;t do checksums</a>, but we can do better. For now, let&rsquo;s use SHA-256 for checksums (Go std lib has it). We&rsquo;ll store the offset, the data, and the checksum.</p><img src=/blag/images/2024/record-format.svg alt="record format"><p>By storing offset we make the record self contained. For e.g. if we do compaction tomorrow and change file names, the record&rsquo;s offset remains same.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>calculateChecksum</span>(<span style=color:#a6e22e>buf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) [<span style=color:#ae81ff>32</span>]<span style=color:#66d9ef>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sha256</span>.<span style=color:#a6e22e>Sum256</span>(<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>Bytes</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>prepareBody</span>(<span style=color:#a6e22e>offset</span> <span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 8 bytes for offset, len(data) bytes for data, 32 bytes for checksum
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>bufferLen</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>+</span> len(<span style=color:#a6e22e>data</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>(make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>bufferLen</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>, <span style=color:#a6e22e>offset</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checksum</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>calculateChecksum</span>(<span style=color:#a6e22e>buf</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>checksum</span>[:])
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>Bytes</span>(), <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=read>Read</h3><p>Our log is coming along nicely! Let&rsquo;s implement the read. It&rsquo;s straightforward. Given an offset, we will construct the appropriate S3 object name and fetch it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>S3WAL</span>) <span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>offset</span> <span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>Record</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>getObjectKey</span>(<span style=color:#a6e22e>offset</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>input</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>GetObjectInput</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Bucket</span>: <span style=color:#a6e22e>aws</span>.<span style=color:#a6e22e>String</span>(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>bucketName</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Key</span>:    <span style=color:#a6e22e>aws</span>.<span style=color:#a6e22e>String</span>(<span style=color:#a6e22e>key</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>GetObject</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>input</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>Body</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>Body</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>data</span>) &lt; <span style=color:#ae81ff>40</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Record</span>{}, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;invalid record: data too short&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>validateOffset</span>(<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>offset</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Record</span>{}, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;offset mismatch&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>validateChecksum</span>(<span style=color:#a6e22e>data</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Record</span>{}, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;checksum mismatch&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Record</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Offset</span>: <span style=color:#a6e22e>offset</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Data</span>:   <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>8</span> : len(<span style=color:#a6e22e>data</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>32</span>],
</span></span><span style=display:flex><span>	}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We will do a couple of validations:</p><ol><li>The record has to be minimum 40 bytes</li><li>The offset in the request should match the one with request</li><li>The checksums should match</li></ol><h3 id=failover--crash-recovery>Failover / Crash Recovery</h3><p>Now that we have our basic operations working, let&rsquo;s handle failure scenarios. What if our node crashes? How do we recover it? We always initialize our WAL with length 0. Subsequently, new writes will try to write at <code>0000000001</code> offset. This is not a catastrophic bug! S3 conditional writes protect us and reject the writes. However, we will not be able to proceed with new writes. Let&rsquo;s fix this. Let&rsquo;s add a method which goes through the list of keys, finds the last inserted object. There are a couple of <a href=https://github.com/avinassh/s3-log/issues/1>ways to optimize this</a>, but let&rsquo;s iterate through all the keys:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WAL</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>LastRecord</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) (<span style=color:#a6e22e>Record</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>S3WAL</span>) <span style=color:#a6e22e>LastRecord</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) (<span style=color:#a6e22e>Record</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>input</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>ListObjectsV2Input</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Bucket</span>: <span style=color:#a6e22e>aws</span>.<span style=color:#a6e22e>String</span>(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>bucketName</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>paginator</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>NewListObjectsV2Paginator</span>(<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>client</span>, <span style=color:#a6e22e>input</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>maxOffset</span> <span style=color:#66d9ef>uint64</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>paginator</span>.<span style=color:#a6e22e>HasMorePages</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>output</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>paginator</span>.<span style=color:#a6e22e>NextPage</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>obj</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>output</span>.<span style=color:#a6e22e>Contents</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>Key</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>offset</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>getOffsetFromKey</span>(<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>offset</span> &gt; <span style=color:#a6e22e>maxOffset</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>maxOffset</span> = <span style=color:#a6e22e>offset</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>maxOffset</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Record</span>{}, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;WAL is empty&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>length</span> = <span style=color:#a6e22e>maxOffset</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>maxOffset</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s it! The project is open source: <a href=https://github.com/avinassh/s3-log>s3-log</a>. You can check the code and some <a href=https://github.com/avinassh/s3-log/blob/master/s3_wal_test.go>tests here</a>. There are a couple of open issues if you&rsquo;d like to contribute!</p><p><small>open issues: <a href=https://github.com/avinassh/s3-log/issues/1>improving LastRecord</a>, <a href=https://github.com/avinassh/s3-log/issues/2>cache</a>, <a href=https://github.com/avinassh/s3-log/issues/3>batch write</a>, <a href=https://github.com/avinassh/s3-log/issues/4>buffered write</a></small>.</p><hr><p><small>1. Any object store would work. But I like S3.</small><br><small>2. Yes, a database is a log.</small><br><small>3. I&rsquo;m not surprised that Jay Kreps ended up loving logs so much he wrote a book <a href>I Heart Logs</a>.</small><br><small>4. <a href=https://x.com/iavins/status/1860299083056849098>Threads are evil</a></small><br><small>5. My fren read this post and asked me, instead of S3, can I use Kafka and store my records there? You definitely can. But running Kafka is not easy. Hosted Kafka is way more expensive than S3. Moreover, you build Kafka-like systems using a log. Going the other way around is recursive.</small><br></p></article><script async data-uid=0576bb9e32 src=https://avin.ck.page/0576bb9e32/index.js></script><footer class=site-footer><div class=rc-scout style=margin-right:auto;margin-top:auto;font-size:.6rem></div><script async defer src="https://www.recurse-scout.com/loader.js?t=a4aabd5087bb19daf083302de1b46650"></script><span class=person-schema itemscope itemtype=http://schema.org/Person><link itemprop=url href=https://avi.im/blag/><span itemprop=name></span><br><a itemprop=sameAs href=https://github.com/avinassh title=GitHub><img src=/blag/svg/gh.svg alt="icon name"></a>
<a itemprop=sameAs href=/blag/index.xml title=GitHub><img src=/blag/svg/rss.svg alt="icon name"></a></span></footer></div><script src=/blag/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script><script data-goatcounter=https://avi.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>